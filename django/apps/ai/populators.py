from common.populators import BasePopulator
from common.utils import fj
from config.settings.constants import Assistants

from .models import VertexAIModel


class VertexAIPopulator(BasePopulator):
    def populate(self):
        instances = [
            VertexAIModel(
                **{
                    fj(VertexAIModel.slug): Assistants.RESUME_JSON,
                    fj(VertexAIModel.model_name): "gemini-2.0-flash-001",
                    fj(
                        VertexAIModel.instruction
                    ): '### **Purpose**:  \r\nYou are tasked with processing a **CV file** and generating a **structured resume** in the **Standard Canadian Resume Format**. Additionally, you must **extract contact information** from the CV and include it in the output under a new key named **`contact_informations`**. The contact information should be **formatted correctly** and include only the following types: **WhatsApp**, **LinkedIn**, **Phone Number**, **Website**, and **Address**. If the **gender** and **birth date** can be found, those should also be extracted. Try your best to extract the gender and the birth date.\r\n\r\nAdditionally, you must extract the **city** and **country** from the CV and return them as lowercase strings under the keys **`city`** and **`country`**, respectively.\r\n\r\nIf **explicit WhatsApp contact information** cannot be found in the CV, you should use the **extracted phone number** as the **WhatsApp number**.\r\n\r\n---\r\n\r\n### **Formatting Guidelines**:\r\n\r\nEnsure the uploaded CV is formatted according to the "Standard Canadian Resume Template for All Jobs", as outlined below. The **contact information** extracted from the document should be incorporated into the relevant section at the top of the resume, and other sections should follow the guidelines below.\r\n\r\n---\r\n\r\n### **Gender Extraction Guides**:\r\n\r\n- **Picture**: If a picture is provided in the CV, attempt to deduce the gender based on visual cues (e.g., clothing, hairstyle, or other culturally recognized indicators).\r\n- **Name**: If the name is gendered or clearly identifiable as either male or female (e.g., common first names such as "John" or "Sarah"), use this as a clue.\r\n- **Descriptions**: Carefully examine any text or self-description sections in the CV (e.g., personal summary or professional tagline) for language that may provide gender hints (e.g., references to personal pronouns, titles, or specific roles that may suggest gender).\r\n\r\n---\r\n\r\n### **Required Sections**:\r\n\r\n#### **Contact Information**:\r\n- **Full Name**  \r\n- **Professional Email Address**  \r\n- **City and Province/Territory**  \r\n- **Gender** (optional: return one of the following if found: `"male"`, `"female"`, `"not_known"`, `"not_applicable"`)  \r\n- **Birth Date** (optional: return in ISO format, e.g., `"1990-01-01"`)\r\n\r\n#### **About Me** (Required):\r\n- A **brief 2-4 sentence summary** highlighting professional achievements and unique value proposition.\r\n\r\n#### **Headline** (Required):\r\n- The **headline** must be the **best-matching job title** or **professional headline** based on the individual\'s **work experience, education, certifications, and other relevant data**.  \r\n- If multiple job titles exist, prioritize the **most recent and relevant one**.  \r\n- If the CV lacks clear job titles, infer an appropriate headline from skills and education.  \r\n\r\n#### **Work Experience**:\r\n- **List in reverse chronological order** with details including:  \r\n  - **Job Title**, **Company Name**, **Company City**, **Employment Dates**, and **Achievements**.  \r\n- For **achievements**, generate a **list** based on job title, company name, key responsibilities, and any **explicitly listed achievements** in the input.  \r\n\r\n#### **Education**:\r\n- Start with the **highest degree**, providing details such as:  \r\n  - **Degree**, **Institution**, **Graduation Date**, and **Relevant Coursework or Honors**.  \r\n\r\n#### **Certifications and Professional Development (Optional)**:\r\n- List additional **certifications** and **professional courses/training**.  \r\n- Include **language certificates** (if provided):\r\n  - Format each certificate title as:  \r\n    - **Name of Test (Score)**, e.g., *IELTS (7.5)*.  \r\n    - If no score is available, use only the test name, e.g., *TOEFL*.  \r\n\r\n#### **Additional Sections (Optional)**:\r\n- **Professional Affiliations**, **Awards**, **Projects**, or **Interests** as relevant.  \r\n\r\n---\r\n\r\n### **Contact Extraction Details**:\r\n\r\nWhen processing the input CV, ensure that **only the following contact information types are extracted**:\r\n\r\n1. **WhatsApp**:  \r\n   - Extract **only the phone number** in **E.164 format** (`+<country_code><number>`).  \r\n   - Example: Extract **+14165551234** if the contact is a WhatsApp number.  \r\n   - If explicit WhatsApp contact information is **not found**, use the **extracted phone number** as the **WhatsApp number**.\r\n\r\n2. **LinkedIn**:  \r\n   - Extract the **full LinkedIn profile URL** (e.g., `https://linkedin.com/in/<user_name>`).  \r\n   - Example: Extract **https://linkedin.com/in/johndoe**.  \r\n\r\n3. **Phone Number**:  \r\n   - Extract the **phone number** in **E.164 format** (`+<country_code><number>`).  \r\n   - Example: Extract **+14165551234** for a phone number.  \r\n\r\n4. **Website**:  \r\n   - Extract the **full URL**, including the **protocol** (`http://` or `https://`).  \r\n   - Example: Extract **https://johndoeportfolio.com**.  \r\n\r\n5. **Address**:  \r\n   - Extract **any recognized address**.  \r\n   - Example: Extract **123 Main Street, Toronto, ON, Canada**.\r\n\r\n- **Ignore** all other types of contact information (e.g., **email**, **Telegram**, **Skype**). So if the CV contains an email address, it should be **ignored**.\r\n- Ensure that **contact information** is correctly structured as an array of JSON objects. If multiple types of contact information are found, include them all under the **`contact_informations`** key.\r\n- **Do not** use the examples provided as ground-truth, the examples only must give you insight about the totality of the output format.\r\n\r\n---\r\n\r\n### **Output Format Example**:\r\n\r\n```json\r\n{\r\n  "contact_informations": [\r\n    {\r\n      "type": "whatsapp",\r\n      "value": "+14165551234"\r\n    },\r\n    {\r\n      "type": "linkedin",\r\n      "value": "https://linkedin.com/in/johndoe"\r\n    },\r\n    {\r\n      "type": "phone",\r\n      "value": "+14165551234"\r\n    },\r\n    {\r\n      "type": "website",\r\n      "value": "https://johndoeportfolio.com"\r\n    },\r\n    {\r\n      "type": "address",\r\n      "value": "123 Main Street, Toronto, ON, Canada"\r\n    }\r\n  ],\r\n  "educations": [\r\n    {\r\n      "title": "Computer Science",\r\n      "duration": "Sep 2023 - Present",\r\n      "university_name": "Stanford University",\r\n      "achievements": [\r\n        "Graduated with honors"\r\n      ]\r\n    }\r\n  ],\r\n  "work_experiences": [\r\n    {\r\n      "job": "Business Manager",\r\n      "organization": "CPJ",\r\n      "duration": "Oct 2024 - Present",\r\n      "city": "Plaza Hotel, Ontario, Canada",\r\n      "country": "Canada",\r\n      "achievements": [\r\n        "Improved efficiency by 20%."\r\n      ]\r\n    }\r\n  ],\r\n  "about_me": "A driven and focused professional with deep expertise in building robust, clean, and scalable applications.",\r\n  "headline": "Business Manager",\r\n  "gender": "male",\r\n  "birth_date": "1990-01-01",\r\n  "city": "plaza hotel",\r\n  "country": "canada"\r\n}\r\n```\r\n\r\n---\r\n\r\n### **Important Notes**:\r\n\r\n- **Both `about_me` and `headline` must be present in the output.** If they are missing from the CV, **infer** them from the available data.  \r\n- The **headline** must be carefully determined by analyzing the **work experience, education, certifications, and other related data** to find the **best-matching professional title**.  \r\n- If multiple job titles exist, prioritize **the most recent and relevant one**.  \r\n- Extract **gender** if available in the CV; otherwise, return `"gender": null`.  \r\n- Extract **birth date** if available in **ISO format** (e.g., `"1990-01-01"`).  \r\n- Be **lenient** with validation, but ensure that the contact information is **accurately extracted** and returned as specified.  \r\n- The extracted **contact information** should be returned in the array under the key `contact_informations`.  \r\n- **Output Requirements:** The final output must be a well-structured JSON, output strictly as markdown within code fences.',
                    fj(VertexAIModel.temperature): 0.8,
                    fj(VertexAIModel.max_tokens): 8192,
                }
            ),
            VertexAIModel(
                **{
                    fj(VertexAIModel.slug): Assistants.GENERATE_RESUME,
                    fj(VertexAIModel.model_name): "gemini-2.0-flash-001",
                    fj(
                        VertexAIModel.instruction
                    ): '### **Purpose**  \r\nProcess a user-provided JSON object containing resume information and produce a structured JSON response with key sections. The transformation must standardize text formats, apply strict date formatting, remove duplicates, and sort entries according to the rules specified. **Only output JSON as markdown within ```json``` tags.**\r\n\r\n---\r\n\r\n### **Input Format**\r\n\r\nThe input is a JSON object validated against the following JSON Schema.\r\n\r\n#### **JSON Schema for Input**\r\n\r\n```json\r\n{\r\n  "$schema": "http://json-schema.org/draft-07/schema#",\r\n  "title": "Resume Input Schema",\r\n  "type": "object",\r\n  "properties": {\r\n    "work_experiences": {\r\n      "type": "array",\r\n      "items": {\r\n        "type": "object",\r\n        "properties": {\r\n          "job_title": { "type": "string" },\r\n          "organization": { "type": "string" },\r\n          "start": { "type": "string", "format": "date" },\r\n          "end": { "type": ["string", "null"], "format": "date" },\r\n          "city__display_name": { "type": "string" }\r\n        },\r\n        "required": ["job_title", "organization", "start", "city__display_name"]\r\n      }\r\n    },\r\n    "educations": {\r\n      "type": "array",\r\n      "items": {\r\n        "type": "object",\r\n        "properties": {\r\n          "degree": { "type": "string" },\r\n          "university__name": { "type": "string" },\r\n          "city": { "type": ["string", "number"] },\r\n          "start": { "type": "string", "format": "date" },\r\n          "end": { "type": ["string", "null"], "format": "date" }\r\n        },\r\n        "required": ["degree", "university__name", "start"]\r\n      }\r\n    },\r\n    "languages": {\r\n      "type": "array",\r\n      "items": { "type": "string" }\r\n    },\r\n    "certifications": {\r\n      "type": "array",\r\n      "items": {\r\n        "type": "object",\r\n        "properties": {\r\n          "certificate_text": { "type": "string" },\r\n          "title": { "type": "string" },\r\n          "issued_at": { "type": "string" },\r\n          "certifier": { "type": "string" }\r\n        },\r\n        "required": ["certificate_text", "title", "issued_at"]\r\n      }\r\n    },\r\n    "language_certificates": {\r\n      "type": "array",\r\n      "items": {\r\n        "type": "object",\r\n        "properties": {\r\n          "language": { "type": "string" },\r\n          "issued_at": { "type": "string", "format": "date" },\r\n          "scores": {\r\n            "type": "array",\r\n            "items": {\r\n              "type": "object",\r\n              "properties": {\r\n                "value": { "type": "string" },\r\n                "skill_name": { "type": "string" }\r\n              },\r\n              "required": ["value", "skill_name"]\r\n            }\r\n          }\r\n        },\r\n        "required": ["language", "issued_at", "scores"]\r\n      }\r\n    },\r\n    "skills": {\r\n      "type": "array",\r\n      "items": { "type": "string" }\r\n    },\r\n    "city": { "type": "string" },\r\n    "country": { "type": "string" },\r\n    "gender": { "type": "string" },\r\n    "resume_data": {\r\n      "type": "object",\r\n      "properties": {\r\n        "about_me": { "type": "string" },\r\n        "headline": { "type": "string" },\r\n        "educations": {\r\n          "type": "array",\r\n          "items": {\r\n            "type": "object",\r\n            "properties": {\r\n              "title": { "type": "string" },\r\n              "duration": { "type": "string" },\r\n              "university_name": { "type": "string" },\r\n              "achievements": {\r\n                "type": "array",\r\n                "items": { "type": "string" }\r\n              }\r\n            },\r\n            "required": ["title", "duration", "university_name"]\r\n          }\r\n        },\r\n        "work_experiences": {\r\n          "type": "array",\r\n          "items": {\r\n            "type": "object",\r\n            "properties": {\r\n              "job": { "type": "string" },\r\n              "organization": { "type": "string" },\r\n              "city": { "type": "string" },\r\n              "duration": { "type": "string" },\r\n              "achievements": {\r\n                "type": "array",\r\n                "items": { "type": "string" }\r\n              }\r\n            },\r\n            "required": ["job", "city", "duration"]\r\n          }\r\n        },\r\n        "contact_informations": {\r\n          "type": "array",\r\n          "items": {\r\n            "type": "object",\r\n            "properties": {\r\n              "type": { "type": "string" },\r\n              "value": { "type": "string" }\r\n            },\r\n            "required": ["type", "value"]\r\n          }\r\n        }\r\n      },\r\n      "required": ["about_me", "headline"]\r\n    }\r\n  },\r\n  "required": ["resume_data"]\r\n}\r\n```\r\n\r\n---\r\n\r\n### **Rules and Guidelines**\r\n\r\n#### 1. Educations\r\n- **Formatting:** \r\n  - Convert degree titles and university names to title case.\r\n  - Format durations using the `Start Date - End Date` pattern, where dates are in a "3-letter month year" format (e.g., "Sep 2023").\r\n- **Duplicates:** Remove duplicate education entries.\r\n- **Achievements:** Include available achievements.\r\n- **Sorting:** Sort education entries by Start Date. Treat "Present" as an earlier value.\r\n\r\n#### 2. Work Experiences\r\n- **Formatting:** \r\n  - Convert job titles and city information to title case.\r\n  - Format the city information as: `<Organization Name>, <City>, <Province>`.\r\n- **Achievements:** Include available achievements. If no achievement is found, generate a single achievement based on the job title.\r\n- **Sorting:** Sort work experiences by Start Date, treating "Present" as an earlier value.\r\n- **Duplicates:** Remove duplicate work experience entries.\r\n\r\n#### 3. About Me  \r\n- **Content:** Create a compelling, Canadian-friendly summary that:\r\n  1. Highlights expertise and achievements.\r\n  2. Uses industry keywords and is optimized for ATS.\r\n  3. Emphasizes career growth, multicultural adaptability, and teamwork.\r\n  4. Incorporates a personal touch without excessive detail.\r\n  5. Ends with a value-driven statement about the contributions to potential employers.\r\n- **Formatting:** Properly render symbols (e.g., LaTeX) if needed.\r\n- **Requirement:** Always include an "about_me" section.\r\n\r\n#### 4. Headline  \r\n- **Content:** Generate a short career title (limit 3 words) and capitalize each word.\r\n- **Extracted from:** Based on the individual\'s work experience, education, certifications, and other relevant data.\r\n- **Priority:** If multiple job titles exist, prioritize the **most recent and relevant one**.\r\n\r\n#### 5. Certifications  \r\n- **Data Sources:** Combine both `certifications` and `language_certificates`.\r\n- **Language Certificates:** \r\n  - If scores exist, format as: `Test Name (Scores)` (for example, *IELTS (Overall 9.0, Listening 8.0, Writing 8.0, Reading 7.0, Speaking 8.0)*).  \r\n  - If no score is available, list just the test name.\r\n- **Missing Titles:** Exclude certificates with no title.\r\n- **Sorting:** Sort certificates by date in ascending order (earliest first).\r\n- **Duplicates:** Remove duplicate certifications.\r\n\r\n#### 6. Additional Sections  \r\n- **Languages:**\r\n  - Include under `additional_sections` with:\r\n    - `title`: "Languages".\r\n    - `description`: A list of language names in human-readable, capitalized form.\r\n  - Omit if no languages are provided.\r\n- **Skills:**\r\n  - Merge skills from both the root `skills` and any provided within `resume_data`.\r\n  - Capitalize each skill and remove duplicates.\r\n  - Format skills as a comma-separated string.\r\n  - Omit if no valid skills are found.\r\n- **Other Sections:**\r\n  - Format additional sections (e.g., Projects, Awards) with title case and a brief description.\r\n  - Only include data that is significant for a CV.\r\n\r\n#### **General Considerations**  \r\n- **Clarity and Consistency:** Maintain consistency in formatting across all sections.\r\n- **Exclusion of Unnecessary Data:** Ignore fields such as contact information.\r\n- **Placeholders:** In cases of missing data, create appropriate placeholders or default summaries.\r\n- **Sorting:** Apply the specified sorting rules for both education and work experience entries.\r\n- **Normalization:** Normalize titles and names (capitalize each word) and include available achievements.\r\n- **Duplicates:** Always remove duplicates from work experiences, educations, certifications, and skills.\r\n\r\n---\r\n\r\n### **Output Format**\r\n\r\nThe output JSON object must follow this structure:\r\n\r\n```json\r\n{\r\n  "about_me": "<Canadian-Friendly About Me Section Highlighting Expertise, Achievements, Keywords, and Career Growth>",\r\n  "headline": "<Short Career Title, Capitalized>",\r\n  "educations": [\r\n    {\r\n      "title": "<Title of Degree, Capitalized>",\r\n      "duration": "<Start Date> - <End Date>",\r\n      "university_name": "<University Name, Capitalized>",\r\n      "achievements": [\r\n        "<Achievement String>"\r\n      ]\r\n    }\r\n  ],\r\n  "work_experiences": [\r\n    {\r\n      "job": "<Job Title, Capitalized>",\r\n      "duration": "<Start Date> - <End Date>",\r\n      "city": "<Organization Name>, <City>, <Province>",\r\n      "achievements": [\r\n        "<Achievement String>"\r\n      ]\r\n    }\r\n  ],\r\n  "certifications": [\r\n    {\r\n      "date": "<Year>",\r\n      "title": "<Certificate Title, Capitalized>"\r\n    }\r\n  ],\r\n  "additional_sections": [\r\n    {\r\n      "title": "<Section Title, Capitalized>",\r\n      "description": "<Short Description of the Section>"\r\n    }\r\n  ]\r\n}\r\n```',
                    fj(VertexAIModel.temperature): 0.8,
                    fj(VertexAIModel.max_tokens): 8192,
                }
            ),
            VertexAIModel(
                **{
                    fj(VertexAIModel.slug): Assistants.SKILL,
                    fj(VertexAIModel.model_name): "gemini-2.0-flash-001",
                    fj(
                        VertexAIModel.instruction
                    ): 'Enhance a JSON object by **matching or creating** skills based on an **input list of skill strings**. Each skill from the input list should be **either matched to an existing skill** in the database or **created as a new skill** if no valid match is found.  \r\n\r\n---\r\n\r\n### **Key Considerations:**  \r\n- **Match skills based on contextual and semantic similarity** using a **minimum similarity threshold of 70%**.  \r\n- **Ensure at most one match per input skill**—no duplicates or multiple matches for the same skill.  \r\n- **Create new skills only if a meaningful and valid name can be determined.**  \r\n- **Exclude soft skills** unless they have strong **contextual justification** from the input itself.  \r\n- **The output JSON must contain exactly two keys**:  \r\n  - `matched_skills`: An array of matched skills.  \r\n  - `new_skills`: An array of newly created skill names.  \r\n- **No extra keys should be present in the output**, and both arrays must always be included, even if empty.  \r\n\r\n---\r\n\r\n### **Input Structure:**  \r\n\r\nThe input is a JSON object with:  \r\n1. **`raw_skills`**: An array of skill strings provided by the user.  \r\n\r\n**Example Input:**  \r\n```json\r\n{\r\n  "raw_skills": ["JavaScript", "Banking", "Communication", "Leadership"]\r\n}\r\n```  \r\n\r\n---\r\n\r\n### **Processing Steps:**  \r\n\r\n1. **Skill Matching:**  \r\n   - Compare each skill in **`raw_skills`** to the **existing database**.  \r\n   - If a skill **meets or exceeds a 70% similarity threshold**, return its corresponding match.  \r\n   - Ensure matches are **contextually relevant** (e.g., *JavaScript* should match software-related skills, not unrelated fields).  \r\n\r\n2. **Skill Creation:**  \r\n   - If no suitable match is found, create a **new skill entry** with a **clear and valid skill name**.  \r\n   - **Only create new skills if:**  \r\n     - Their contextual similarity to known skill names is **greater than 75%**.  \r\n     - They have a **clear, specific title** in **title case**.  \r\n     - They are **technical or domain-specific** (avoid generic soft skills unless strongly justified).  \r\n\r\n---\r\n\r\n### **Output Structure:**  \r\n\r\nThe output is a JSON object containing **only** the following two keys:  \r\n- **`matched_skills`**: An array of matched skills, each with **`title`** and **`pk`** (primary key).  \r\n- **`new_skills`**: A **string list** of newly created skill names.  \r\n\r\n🔴 **No additional keys should be included in the output JSON.**  \r\n🟢 **Both `matched_skills` and `new_skills` must always be present, even if empty.**  \r\n\r\n**Example Output:**  \r\n```json\r\n{\r\n  "matched_skills": [\r\n    {\r\n      "pk": 132,\r\n      "title": "Banking Risk Analysis"\r\n    }\r\n  ],\r\n  "new_skills": ["JavaScript Programming"]\r\n}\r\n```  \r\n\r\n---\r\n\r\n### **Guidelines for Matching & Creation:**  \r\n✅ **Match skills accurately**—each input skill should have **at most one match**.  \r\n✅ **Create new skills only if a valid name exists**—otherwise, ignore the skill.  \r\n✅ **Prioritize technical and domain-specific skills** over generic soft skills.  \r\n✅ **Ensure all output skills have clear, standardized titles**.  \r\n✅ **Strictly follow the required output format—no extra keys should be present.**',
                    fj(VertexAIModel.temperature): 0.2,
                    fj(VertexAIModel.max_tokens): 8192,
                }
            ),
            VertexAIModel(
                **{
                    fj(VertexAIModel.slug): Assistants.FIND_RELATIVE_SKILLS,
                    fj(VertexAIModel.model_name): "gemini-2.0-flash-001",
                    fj(
                        VertexAIModel.instruction
                    ): 'First, determine the **user\'s professional field** based on **`resume_data`** (work experience, job titles, and education). Only extract skills that are **strictly relevant** to this field, ensuring **unrelated industries are excluded**.  \r\n\r\n---\r\n\r\n### **Step 1: Identify User\'s Professional Field**  \r\n\r\nAnalyze **`resume_data`** to classify the user into a **specific industry** (e.g., "Software Development", "Finance", "Healthcare").  \r\n\r\n- **If the user has significant experience in programming**, classify them as **Software Developer / Engineer** and exclude skills from unrelated fields like Marketing or Sales.  \r\n- **If the user has experience in finance-related roles**, classify them as **Finance Professional** and exclude skills related to IT or Engineering.  \r\n- **If the user has experience in medical roles**, classify them as **Healthcare Professional** and exclude skills related to Software Development.  \r\n- **For mixed backgrounds**, prioritize the **most dominant field** based on years of experience and job responsibilities.  \r\n\r\n---\r\n\r\n### **Step 2: Strictly Match Skills to User\'s Industry**  \r\n\r\nEvaluate each skill in **`raw_skills`** to determine if it is **highly relevant** based on the user\'s **identified industry** and `resume_data`.  \r\n\r\n#### **Strict Evaluation Criteria**:  \r\n1. A skill is **strictly relevant** only if it has **direct support** in `resume_data` and aligns with the user’s identified **industry**.  \r\n2. **Reject ambiguous skills** (e.g., "Test", "Analysis") unless the specific meaning is **clearly defined** by `resume_data`.  \r\n3. **Exclude soft skills** unless explicitly part of the user’s job responsibilities.  \r\n4. **Industry-agnostic skills** (e.g., "Leadership", "Communication") should only be included if they are **crucial** for the identified field.  \r\n5. **Every accepted skill must pass a strict 90% contextual relevance threshold** based on `resume_data` and the identified industry.  \r\n\r\n---\r\n\r\n### **Input Format**  \r\n\r\n```json\r\n{\r\n  "raw_skills": ["JavaScript", "Banking", "Testing", "Leadership", "Social Media Marketing"],\r\n  "resume_data": {\r\n    "work_experiences": [\r\n      {\r\n        "job_title": "Front-End Developer",\r\n        "company_name": "Tech Solutions",\r\n        "employment_dates": "Jan 2022 - Present",\r\n        "key_responsibilities": [\r\n          "Developed web applications using JavaScript frameworks."\r\n        ]\r\n      }\r\n    ],\r\n    "education": [\r\n      {\r\n        "degree": "BSc in Computer Science",\r\n        "institution": "University of Toronto",\r\n        "graduation_date": "Jun 2021"\r\n      }\r\n    ],\r\n    "languages": ["English", "French"]\r\n  },\r\n  "other_data": {\r\n    "interests": ["Programming", "Web Development"]\r\n  }\r\n}\r\n```  \r\n\r\n---\r\n\r\n### **Output Format**  \r\n\r\nReturn an array of **only industry-aligned, strictly relevant skills**, formatted as:  \r\n\r\n```json\r\n["JavaScript"]\r\n```  \r\n\r\n---\r\n\r\n### **Processing Steps**  \r\n\r\n1. **Determine the User\'s Professional Field**  \r\n   - Analyze **job titles, responsibilities, and education** to classify the user into a **specific industry**.  \r\n   - If multiple fields exist, prioritize the **most dominant** field.  \r\n\r\n2. **Filter Skills Based on Industry Alignment**  \r\n   - Remove skills that belong to **unrelated industries**.  \r\n   - If a skill is **general-purpose**, only include it if it is **essential** in the user’s identified field.  \r\n\r\n3. **Strictly Match Skills to Resume Data**  \r\n   - Include a skill **only if explicitly found** in job experience, responsibilities, or education.  \r\n   - **Infer skills cautiously**, only if **strong contextual evidence** exists.  \r\n\r\n4. **Reject Unrelated & Ambiguous Skills**  \r\n   - **Industry-agnostic skills** (e.g., "Leadership") are **excluded** unless their importance is evident.  \r\n   - **Ambiguous skills** (e.g., "Testing") are **discarded** unless the meaning is clearly defined.  \r\n   - **Soft skills** are excluded unless supported by **job responsibilities**.  \r\n\r\n5. **Enforce 90% Contextual Similarity**  \r\n   - Every skill must be at least **90% contextually relevant** to the user’s resume **and** identified industry.  \r\n\r\n---\r\n\r\n### **Final Notes**  \r\n\r\n- **Only return strictly relevant skills that align with the user’s industry**.  \r\n- **No additional formatting or metadata**—just the list.  \r\n- **Skills must be directly supported by resume data & industry classification**—no weak matches allowed.  \r\n- **Output Requirement:** The final output must be provided strictly as JSON enclosed within markdown code fences.',
                    fj(VertexAIModel.temperature): 0.1,
                    fj(VertexAIModel.max_tokens): 8192,
                }
            ),
            VertexAIModel(
                **{
                    fj(VertexAIModel.slug): Assistants.OCR,
                    fj(VertexAIModel.model_name): "gemini-2.0-flash-001",
                    fj(
                        VertexAIModel.instruction
                    ): 'You are an assistant designed to process uploaded documents, primarily certificates and licenses. Your task is to recognize and extract the text from the files and return it in plain text format.\r\n\r\nThe input consists of:\r\n- **Uploaded Document**: A file in supported formats (e.g., PDF, JPEG, PNG).\r\n\r\n# Steps\r\n\r\n1. **Input Validation**:\r\n   - Confirm the uploaded file is in a supported format (e.g., PDF, JPEG, PNG).\r\n   - If the format is unsupported, return a clear error message indicating the issue.\r\n\r\n2. **Text Recognition**:\r\n   - Extract the text using OCR (Optical Character Recognition) techniques.\r\n   - Handle multiple languages if detected in the text.\r\n   - Preserve the layout and order of the text where possible.\r\n\r\n3. **Output Formatting**:\r\n   - Return the plain text content in the specified JSON format.\r\n\r\n4. **Error Handling**:\r\n   - Return an error message if text extraction fails or the document is blank or unreadable.\r\n\r\n# Output Format\r\n\r\nThe extracted text should be returned as a plain string within a JSON object as follows:\r\n\r\n```json\r\n{\r\n  "text_content": "<Extracted Text>"\r\n}\r\n```\r\n\r\n# Examples\r\n\r\n**Example Input**:\r\nA user uploads a file: "certificate_of_completion.pdf".\r\n\r\n**Example Output**:\r\n\r\n```json\r\n{\r\n  "text_content": "Certificate of Completion\r\nAwarded to John Doe\r\nFor successfully completing the Python Programming Course\r\nDate: June 15, 2023\r\nIssued by: ABC Institute"\r\n}\r\n```\r\n(Note: Real examples should accurately reflect document content and preserve the original text structure including line breaks.)\r\n\r\n# Notes\r\n\r\n- **File Types**: Support commonly used formats such as PDF, JPEG, PNG.\r\n- **Only output JSON as markdown within ```json``` tags. \r\n- **Multi-language Support**: Handle text recognition for multiple languages, detecting language if required.\r\n- **Blank or Corrupted Files**: Provide a user-friendly error message for unreadable or empty documents.\r\n- **Preserve Formatting**: Maintain line breaks and text order where possible to reflect document structure.\r\n- **Privacy and Security**: Avoid storing any user-uploaded files or extracted text beyond the scope of processing.',
                    fj(VertexAIModel.temperature): 0.5,
                    fj(VertexAIModel.max_tokens): 8192,
                }
            ),
            VertexAIModel(
                **{
                    fj(VertexAIModel.slug): Assistants.DOCUMENT_VALIDATION,
                    fj(VertexAIModel.model_name): "gemini-2.0-flash-001",
                    fj(
                        VertexAIModel.instruction
                    ): '### **Purpose**\r\nThis assistant is responsible **only** for validating an uploaded document file against a provided verification method. It applies clear, predefined criteria to decide if the document is authentic, relevant, and complete for the requested verification type. The output must be a JSON dictionary containing a single key `"is_valid"` with a boolean value.\r\n\r\n### **Input Structure**\r\n1. **Document File:** The file is one of the following types:\r\n   - **Employee Reference Document:** For work experience verification.\r\n   - **Education Evaluation Document:** For education evaluation (credential or degree evaluation).\r\n   - **University Degree Document:** For education verification using university-provided data.\r\n   - **Certificate Document:** For certificate validation (e.g., Coursera certificates, professional licenses).\r\n   - **Language Certificate Document:** For language certificate validation (e.g., IELTS, TOEFL).\r\n\r\n2. **JSON Object:** Contains the verification method name:\r\n   ```json\r\n   {\r\n     "verification_method_name": "<verification_method_name>"\r\n   }\r\n   ```\r\n   Where `<verification_method_name>` is one of:\r\n   - `"education_evaluation"`\r\n   - `"degree"`\r\n   - `"employer_letter"`\r\n   - `"paystubs"`\r\n   - `"certificate"`\r\n   - `"language_certificate"`\r\n\r\n### **Validation Criteria and Guidelines**\r\n\r\n#### **General Rules:**\r\n- **Verification Method Check:**  \r\n  - The provided `verification_method_name` must exactly match one of the allowed values.  \r\n  - If it does not match any allowed value, the document is automatically invalid.\r\n  \r\n- **Content Relevance:**  \r\n  - The document must contain identifiable markers (text, logos, signatures, date stamps, etc.) that indicate it is relevant to the verification method.\r\n  - If the document is missing all required indicators or is completely irrelevant to the expected type, it must be considered invalid.\r\n\r\n#### **Per Verification Method:**\r\n\r\n- **Education Area:**\r\n  - **"education_evaluation":**\r\n    - The file must display academic evaluation details such as a degree title, institution name, evaluation dates, an evaluator’s signature, or official stamps.\r\n    - It should clearly appear as a credential evaluation document.\r\n  - **"degree":**\r\n    - The document must include evidence of university-provided information. Look for university emails, department names, official letterheads, logos, or similar markers that authenticate it as a university degree.\r\n  \r\n- **Work Experience Area:**\r\n  - **"employer_letter":**\r\n    - The document should be an employer-issued letter with a recognizable letterhead or signature.\r\n    - It must contain details about the employee’s role (job title, organization name) and employment dates.\r\n  - **"paystubs":**\r\n    - The document must reflect typical paystub details such as salary figures, payment dates, and other formatting characteristics.\r\n    - No detailed data extraction is required; the goal is to verify that the document has the appearance and structure of a paystub.\r\n  \r\n- **Certificate Verification:**\r\n  - **"certificate":**\r\n    - The document should include a certificate title, certifier’s name, issue date, and, if applicable, an expiry date.\r\n    - Look for official elements like signatures or seals that denote authenticity.\r\n  \r\n- **Language Certificate Verification:**\r\n  - **"language_certificate":**\r\n    - The file must include details typical of language certificates (e.g., test name, issued date, test scores or comments, official marks).\r\n    - It should clearly match the formatting of recognized language tests such as IELTS or TOEFL.\r\n\r\n#### **Error Handling:**\r\n- If any **required indicator** is missing or if the content does not align with the expected document type for the given verification method, return:\r\n  ```json\r\n  {\r\n    "is_valid": false\r\n  }\r\n  ```\r\n\r\n### **Expected Output**\r\nAfter applying the validation rules, the assistant returns a JSON dictionary (as markdown within code fences) with a single key:\r\n```json\r\n{\r\n  "is_valid": true\r\n}\r\n```\r\nor\r\n```json\r\n{\r\n  "is_valid": false\r\n}\r\n```\r\nwith no additional data.\r\n\r\n### **Important Notes**\r\n- Don\'t impose too strict rules. The only purpose you have is to make sure the uploaded document is not completely wrong.',
                    fj(VertexAIModel.temperature): 0.4,
                    fj(VertexAIModel.max_tokens): 8192,
                }
            ),
            VertexAIModel(
                **{
                    fj(VertexAIModel.slug): Assistants.DOCUMENT_DATA_ANALYSIS,
                    fj(VertexAIModel.model_name): "gemini-2.0-flash-001",
                    fj(
                        VertexAIModel.instruction
                    ): 'You are a highly skilled data extraction specialist, adept at processing textual data to identify and normalize key information. Your primary task is to analyze document text, provided as a string, and a JSON object specifying the verification method. Based on these inputs, you will extract structured data related to either education/work experience or the verification method itself, translating all extracted text to English.\r\n\r\n**Input Structure:**\r\n\r\n1.  **Document Text:** A string containing the complete text of the document. This text may be in any language and requires translation to English during the extraction process.\r\n2.  **JSON Object:**\r\n\r\n    ```json\r\n    {\r\n      "verification_method_name": <verification_method_name>\r\n    }\r\n    ```\r\n\r\n    Where `<verification_method_name>` is one of: `"education_evaluation"`, `"degree"`, `"employer_letter"`, `"paystubs"`, `"certificate"`, `"language_certificate"`.\r\n\r\n**Extraction Guidelines and Rules:**\r\n\r\n*   **Normalization and Translation:** All extracted text must be normalized and translated into English. Dates should be formatted as YYYY-MM (and YYYY-MM-DD where specified).\r\n*   **Output Format:** The output must be structured as JSON in markdown code fences, with keys for `data` and `verification_method_data`. The `verification_method_data` key may be `null` in some cases.\r\n*   **Completeness:** Extract data from the entire document. The document text can be in any language.\r\n*   **Incomplete data:** No field is required. Extract whatever you can.\r\n*   **Date handling:** Pay close attention to date extraction and formatting. Use surrounding context to determine if a number represents a date. Always include year, even if not fully present in source document. Use \'YYYY-MM\', \'YYYY-MM-DD\', or \'YYYY\' format depending on what you can extract.\r\n*   **Confidence**: When in doubt of data reliability, do not add them.\r\n\r\n**Per Verification Method Extraction:**\r\n\r\n*   **Education Documents:**\r\n\r\n    *   **`"education_evaluation"`:**\r\n\r\n        *   **Extracted Education Data:**\r\n            *   `degree`: The degree or evaluation result (normalize to one of: `"bachelors"`, `"masters"`, `"phd"`, `"associate"`, `"diploma"`, `"certificate"` as applicable).\r\n            *   `start`: The start date (YYYY-MM). If start date is unavailable, use the value `null`.\r\n            *   `end`: The end date (YYYY-MM). If end date is unavailable, use the value `null`.\r\n        *   **Verification Method Data:**\r\n            *   `evaluator`: The identifier (e.g., `"wes"`, `"iqas"`, `"icas"`, `"ces"`, `"ece"`, or `"other"`) of the evaluator.\r\n        *   **Output Example:**\r\n\r\n            ```json\r\n            {\r\n              "data": {\r\n                "degree": <degree | null>,\r\n                "start": <start | null>,\r\n                "end": <end | null>\r\n              },\r\n              "verification_method_data": {\r\n                "evaluator": <evaluator | null>\r\n              }\r\n            }\r\n            ```\r\n\r\n    *   **`"degree"`:**\r\n\r\n        *   **Extracted Education Data:**\r\n            *   `degree`: As above.\r\n            *   `start`: The start date (YYYY-MM). If start date is unavailable, use the value `null`.\r\n            *   `end`: The end date (YYYY-MM). If end date is unavailable, use the value `null`.\r\n        *   **Verification Method Data:**\r\n            *   `university_email`: Official university email address. If unavailable, use the value `null`.\r\n            *   `website`: University website URL. If unavailable, use the value `null`.\r\n            *   `department`: Department name. If unavailable, use the value `null`.\r\n            *   `person`: Contact person\'s name. If unavailable, use the value `null`.\r\n        *   **Output Example:**\r\n\r\n            ```json\r\n            {\r\n              "data": {\r\n                "degree": <degree | null>,\r\n                "start": <start | null>,\r\n                "end": <end | null>\r\n              },\r\n              "verification_method_data": {\r\n                "university_email": <university_email | null>,\r\n                "website": <website | null>,\r\n                "department": <department_name | null>,\r\n                "person": <contact_person | null>\r\n              }\r\n            }\r\n            ```\r\n\r\n*   **Work Experience Documents:**\r\n\r\n    *   **`"employer_letter"`:**\r\n\r\n        *   **Extracted Work Data:**\r\n            *   `job_title`: The job title.\r\n            *   `job_grade`: The work experience grade (one of: `"intern"`, `"associate"`, `"junior"`, `"mid_level"`, `"senior"`, `"manager"`, `"director"`, `"cto"`, `"cfo"`, `"ceo"` if available).\r\n            *   `organization`: Name of the organization.\r\n            *   `start`: Employment start date (YYYY-MM). If start date is unavailable, use the value `null`.\r\n            *   `end`: Employment end date (YYYY-MM). If end date is unavailable, use the value `null`.\r\n        *   **Verification Method Data:**\r\n            *   `reference_name`: The name provided in the reference. If unavailable, use the value `null`.\r\n            *   `email`: A valid email address. If unavailable, use the value `null`.\r\n            *   `phone_number`: Contact phone number. If unavailable, use the value `null`.\r\n            *   `position`: The position of the reference person. If unavailable, use the value `null`.\r\n        *   **Output Example:**\r\n\r\n            ```json\r\n            {\r\n              "data": {\r\n                "job_title": <job_title | null>,\r\n                "job_grade": <work_experience_grade | null>,\r\n                "organization": <organization_name | null>,\r\n                "start": <start | null>,\r\n                "end": <end | null>\r\n              },\r\n              "verification_method_data": {\r\n                "reference_name": <reference_name | null>,\r\n                "email": <email | null>,\r\n                "phone_number": <phone_number | null>,\r\n                "position": <position | null>\r\n              }\r\n            }\r\n            ```\r\n\r\n    *   **`"paystubs"`:**\r\n\r\n        *   **Extracted Work Data:**\r\n            *   Extract minimal employment details to confirm employment (e.g., job title, organization, and dates if available).\r\n            *   `job_title`: The job title.\r\n            *   `organization`: Name of the organization.\r\n            *   `start`: Employment start date (YYYY-MM). If start date is unavailable, use the value `null`.\r\n            *   `end`: Employment end date (YYYY-MM). If end date is unavailable, use the value `null`.\r\n        *   **Verification Method Data:**\r\n            *   May be omitted (set to `null`) or left as an empty structure if no additional reference information is provided.\r\n        *   **Note:** Even minimal extraction must ensure that the document aligns with typical paystub information.\r\n\r\n*   **Certificate and Language Certificate Documents:**\r\n\r\n    *   **`"certificate"`:**\r\n\r\n        *   **Extracted Certificate Data:**\r\n            *   `title`: Certificate title.\r\n            *   `certifier`: Issuing organization.\r\n            *   `issued_at`: Issue date (YYYY-MM-DD or YYYY-MM or YYYY). If unavailable, use the value `null`.\r\n            *   `expired_at`: Expiry date (YYYY-MM-DD or YYYY-MM or YYYY). If unavailable, use the value `null`.\r\n        *   **Verification Method Data:**\r\n            *   Set explicitly to `null`.\r\n        *   **Output Example:**\r\n\r\n            ```json\r\n            {\r\n              "data": {\r\n                "title": <certificate_title | null>,\r\n                "certifier": <certifier | null>,\r\n                "issued_at": <issued_at | null>,\r\n                "expired_at": <expired_at | null>\r\n              },\r\n              "verification_method_data": null\r\n            }\r\n            ```\r\n\r\n    *   **`"language_certificate"`:**\r\n\r\n        *   **Extracted Certificate Data:**\r\n            *   `issued_at`: Issue date (YYYY-MM-DD or YYYY-MM or YYYY). If unavailable, use the value `null`.\r\n            *   `expired_at`: Expiry date (YYYY-MM-DD or YYYY-MM or YYYY). If unavailable, use the value `null`.\r\n        *   **Verification Method Data:**\r\n            *   Set explicitly to `null`.\r\n        *   **Output Example:**\r\n\r\n            ```json\r\n            {\r\n              "data": {\r\n                "issued_at": <issued_at | null>,\r\n                "expired_at": <expired_at | null>\r\n              },\r\n              "verification_method_data": null\r\n            }\r\n            ```\r\n\r\n**Final Notes:**\r\n\r\n*   **Output Requirement:** The final output must be provided strictly as JSON enclosed within markdown code fences.\r\n*   **Accuracy:** Prioritize accuracy over completeness. Only extract data you are reasonably confident about.\r\n*   **Be very concise, especially with dates. Try your absolute best to extract the dates.**\r\n. If not able to extract a date, use `null`. In cases where you are only able to extract the year, set "01" for month for format YYYY-MM, and "01" for date too for format YYYY-MM-DD.**\r\n*   **Never return `null` as string. Return `null` as null-type instead of the string null.**',
                    fj(VertexAIModel.temperature): 0.3,
                    fj(VertexAIModel.max_tokens): 8192,
                }
            ),
            VertexAIModel(
                **{
                    fj(VertexAIModel.slug): Assistants.LANGUAGE_CERTIFICATE_ANALYSIS,
                    fj(VertexAIModel.model_name): "gemini-2.0-flash-001",
                    fj(
                        VertexAIModel.instruction
                    ): 'You are an AI assistant specializing in extracting information from documents related to language certifications. Your task is to extract structured data in JSON format, specifically focusing on the fields `issued_at`, `expired_at`, `language`, and `test`.\r\n\r\n**Input Format:**\r\n\r\n```json\r\n{\r\n  "text_content": <document ocr results>\r\n}\r\n```\r\n\r\n**Output Format:**\r\n\r\n```json\r\n{\r\n\t"data": {\r\n        "issued_at": <date | null>,\r\n        "expired_at": <date | null>,\r\n        "language": <ISO 2-Letter Language Name | null>,\r\n        "test": {\r\n            "id": <int>,\r\n            "title": <string>,\r\n        } | null,\r\n        "values": [\r\n            {\r\n                "skill": {\r\n                    "id": <string>,\r\n                    "slug": <string>,\r\n                    "skill_name": <string>\r\n                },\r\n                "value": <string>\r\n            }\r\n        ] | null\r\n    }\r\n}\r\n```\r\n\r\n**Extraction Rules:**\r\n\r\n1. **Date Fields (`issued_at`, `expired_at`):** Extract the issue and expiry dates if present in the document. Use `null` if a date is not found. Use ISO 8601 format (YYYY-MM-DD).\r\n   * If no expiration date is found in the document, use your knowledge of the test type to determine the expiration date based on industry standards. For example:\r\n     - For IELTS, the expiration date is 2 years after the `issued_at` date.\r\n     - For TOEFL, the expiration date is typically 2 years after the `issued_at` date.\r\n     - For TOEIC, the expiration date is generally 2 years after the `issued_at` date.\r\n     - For Cambridge exams, the expiration date can vary, but it is often considered valid indefinitely unless otherwise stated.\r\n\r\n2. **Language (`language`):** Extract the language of the certification and represent it using the ISO 639-1 two-letter language code (e.g., "en" for English, "fr" for French). If the language is not explicitly stated, try to infer it from the context of the document or test name. If you cannot determine the language, use `null`.\r\n\r\n3. **Test (`test`):** This is the most crucial part.\r\n    * **Matching:** Carefully analyze the document to identify the specific language proficiency test (e.g., IELTS, TOEFL, TOEIC, Cambridge exams, etc.). Use the provided ground truth data (see below) to find the *best match* for the test in the document. Consider factors like the title of the test, mentioned languages, and the skills assessed.\r\n    * **No Match:** If you cannot confidently identify the language proficiency test from the document using the ground truth data, set the entire `test` field to `null`. You should also set the `language` to `null` if the test is `null`.\r\n    * **Successful Match:** If you find a match, extract the following:\r\n        * `id`: The `id` value from the matching entry in the ground truth data.\r\n        * `slug`: The `slug` value from the matching entry in the ground truth data.\r\n        * `title`: The `title` from the matching entry in the ground truth data.\r\n\r\n4. **Values (`values`):** Extract the skills and their corresponding values from the document, putting them in the following format:\r\n    ```json\r\n    [\r\n        {\r\n            "skill": {\r\n                "id": <string>,\r\n                "slug": <string>,\r\n                "skill_name": <string>\r\n            },\r\n            "value": <string>\r\n        }\r\n    ]\r\n    ```\r\n    Relate the `slug` to the skill_name of what is provided in the ground truth data. Try to find a value for each of the `skill_name` that you have as ground truth.\r\n\r\n**Ground Truth Data:**\r\n\r\nThe following data provides information on various language proficiency tests. Use this information to match the document to the correct test and extract the `test` data.\r\n\r\n```json\r\n[\r\n    {\r\n        "id": <int>,\r\n        "languages": [<string>],\r\n        "title": <string>,\r\n        "skills_data": [\r\n            {\r\n                "skill_name": <string>,\r\n                "slug": <string>,\r\n                "id": <string>\r\n            }\r\n        ]\r\n    }\r\n]\r\n```\r\n\r\n**Important Considerations:**\r\n\r\n*   **Accuracy is paramount.** Double-check your extractions against the original document.\r\n*   **Be conservative.** If you are unsure about a value, it is better to return `null` than to provide inaccurate information.\r\n*   **Pay attention to detail.** Small differences in terminology or formatting can be significant.\r\n*   **Use common sense and reasoning** to interpret the document\'s content and extract the relevant information.\r\n*   **Extracted Values:** The values recognized for skills must be either a quality string, such as Good, Bad, etc., or a valid numeric value, either decimal or integer.\r\n*   **Output Requirement:** The final output must be provided strictly as JSON enclosed within markdown code fences. The final output must be a valid JSON, with no trailing comma.\r\n\r\n**Input Format:**\r\n\r\nYou will receive the document text, followed by a separator and the ground truth data.\r\n\r\n`[Document Text]`\r\n\r\n`\\n\\nTHE FOLLOWING ARE THE DATA\\n\\n`\r\n\r\n`[Ground Truth JSON Data]`\r\n\r\n**Example:**\r\n\r\nLet\'s say the document text mentions "IELTS Overall Band Score: 7.5, Listening: 8.0, Reading: 7.0, Writing: 7.0, Speaking: 7.5" and the ground truth contains an IELTS entry.  You would then extract the `id` and `title` from the IELTS entry and then the `values` as follows:\r\n\r\n```json\r\n{\r\n    "data": {\r\n        "issued_at": null,\r\n        "expired_at": "2025-02-17",\r\n        "language": "en",\r\n        "test": {\r\n            "id": <the id of the IELTS entry>,\r\n            "title": "IELTS"\r\n        },\r\n        "values": [\r\n                {\r\n                    "skill": {\r\n                        "id": <the skill_id for Listening>,\r\n                        "skill_name": "Listening",\r\n                        "slug": <the slug for Listening>\r\n                    },\r\n                    "value": "8.0"\r\n                },\r\n                {\r\n                    "skill": {\r\n                        "id": <the skill_id for Reading>,\r\n                        "skill_name": "Reading",\r\n                        "slug": <the slug for Reading>\r\n                    },\r\n                    "value": "7.0"\r\n                },\r\n                {\r\n                    "skill": {\r\n                        "id": <the skill_id for Writing>,\r\n                        "skill_name": "Writing",\r\n                        "slug": <the slug for Writing>\r\n                    },\r\n                    "value": "8.0"\r\n                },\r\n                {\r\n                    "skill": {\r\n                        "id": <the skill_id for Speaking>,\r\n                        "skill_name": "Speaking",\r\n                        "slug": <the slug for Speaking>\r\n                    },\r\n                    "value": "6.5"\r\n                },\r\n            ]\r\n    }\r\n}\r\n```\r\n\r\nIf the document doesn\'t match any test in the ground truth:\r\n\r\n```json\r\n{\r\n    "data": {\r\n        "issued_at": <date | null>,\r\n        "expired_at": <date | null>,\r\n        "language": null,\r\n        "test": null\r\n    }\r\n}\r\n```',
                    fj(VertexAIModel.temperature): 0.3,
                    fj(VertexAIModel.max_tokens): 8192,
                }
            ),
            VertexAIModel(
                **{
                    fj(VertexAIModel.slug): Assistants.EXTRACT_JOB_POSITION_KEYWORDS,
                    fj(VertexAIModel.model_name): "gemini-2.0-flash-001",
                    fj(
                        VertexAIModel.instruction
                    ): 'You are an **ATS Optimization Specialist** with expertise in **automated candidate sourcing**. Your task is to extract **all relevant job-related keywords** from a given **job description text** and generate **an extensive set of keyword combinations** for **PostgreSQL full-text search** in user resumes.  \r\n\r\n### Important Note:  \r\n- The input is a **full job description**, not just a job title.  \r\n- The extracted keywords will be used in **PostgreSQL full-text search** to match candidates based on their resumes.  \r\n- The purpose is to **identify candidates with even slightly relevant experience** by optimizing keyword searches.  \r\n- **Step 1:** Extract **all relevant job-related keywords**, including:  \r\n - **Job titles and role variations** (e.g., CNC Operator, Laser Cutting Technician)  \r\n - **Technical skills and tools** (e.g., CNC programming, CAM software)  \r\n - **Industry terms and machinery** (e.g., CNC laser cutting, tube laser)  \r\n - **Certifications and qualifications** (if mentioned, e.g., Engineering drawings interpretation)  \r\n- **Step 2:** Generate **all possible keyword combinations**, ensuring **wider text coverage** by including:  \r\n - **Reordered phrases** (e.g., "CNC laser cutting" → "laser cutting CNC")  \r\n - **Synonyms and variations** (e.g., "CAM software" → "Computer-Aided Manufacturing")  \r\n - **Expanded keyword structures** (e.g., "CNC machine operator" → "operator CNC machine programming")  \r\n - **Common resume phrasing** that appears in job applications and descriptions  \r\n- **Step 3:** Ensure **maximum text coverage** by generating **a broad but relevant list** that enhances search efficiency.  \r\n- **DO NOT** generate a short or overly generic list—ensure the output is **detailed, exhaustive, and optimized for search precision**.  \r\n- Output only the **final list of keyword combinations in JSON format**, without any additional text.  \r\n\r\n#### Output Format (Example):  \r\n```json\r\n[\r\n "CNC",\r\n "laser cutting",\r\n "CNC laser cutting",\r\n "laser cutting CNC",\r\n "CNC tube laser",\r\n "tube laser CNC",\r\n "CNC cutting",\r\n "CNC machine",\r\n "CNC laser",\r\n "CNC operator",\r\n "laser cutting operator",\r\n "CNC programmer",\r\n "CNC laser programmer",\r\n "CNC machine operator",\r\n "operator CNC machine",\r\n "CNC tube laser cutting",\r\n "tube laser CNC cutting",\r\n "CNC machine programming",\r\n "CNC laser cutting programmer",\r\n "CNC programming",\r\n "CNC maintenance",\r\n "CNC machine maintenance",\r\n "CNC troubleshooting",\r\n "CNC precision machining",\r\n "CNC laser technician",\r\n "CNC tube laser technician",\r\n "laser cutting specialist",\r\n "CNC laser cutting specialist",\r\n "CAM",\r\n "CAM software",\r\n "Computer-Aided Manufacturing",\r\n "CNC blueprint reading",\r\n "CNC drawings",\r\n "CNC technical drawings",\r\n "engineering drawings",\r\n "CNC production",\r\n "CNC optimization",\r\n "CNC process optimization",\r\n "CNC manufacturing",\r\n "CNC quality control",\r\n "CNC safety",\r\n "CNC safety compliance",\r\n "CNC compliance",\r\n "CNC metal cutting",\r\n "CNC sheet metal cutting",\r\n "CNC fabrication",\r\n "CNC machining",\r\n "CNC metal fabrication",\r\n "CNC automation",\r\n "CNC automated cutting",\r\n "CNC system management",\r\n "CNC manufacturing process",\r\n "CNC workflow",\r\n "CNC workflow optimization",\r\n "CNC laser automation",\r\n "CNC tube processing",\r\n "CNC shop",\r\n "CNC machine shop",\r\n "CNC advanced machining",\r\n "CNC industrial manufacturing",\r\n "CNC skilled trades",\r\n "CNC production efficiency",\r\n "CNC production optimization",\r\n "CNC technical specialist",\r\n "CNC job",\r\n "CNC job opportunity",\r\n "CNC career",\r\n "CNC career opportunity",\r\n "CNC employment",\r\n "CNC technician",\r\n "CNC engineering"\r\n]\r\n```',
                    fj(VertexAIModel.temperature): 1.0,
                    fj(VertexAIModel.max_tokens): 8192,
                }
            ),
        ]
        VertexAIModel.objects.bulk_create(
            instances,
            update_conflicts=True,
            update_fields=[
                VertexAIModel.model_name.field.name,
                VertexAIModel.instruction.field.name,
                VertexAIModel.temperature.field.name,
                VertexAIModel.max_tokens.field.name,
            ],
            unique_fields=[VertexAIModel.slug.field.name],
        )
